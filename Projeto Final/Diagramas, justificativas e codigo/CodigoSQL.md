CREATE TABLE PLANO_SAUDE (
  plano_id        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome            VARCHAR2(200),
  operadora       VARCHAR2(200),
  numero_contrato VARCHAR2(100),
  cobertura       CLOB
);

CREATE TABLE PROFISSIONAL (
  profissional_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome            VARCHAR2(200) NOT NULL,
  cpf             VARCHAR2(14) UNIQUE,
  tipo_profissional VARCHAR2(50),
  registro        VARCHAR2(60),
  email           VARCHAR2(150),
  data_contratacao DATE,
  rua             VARCHAR2(150),
  numero          VARCHAR2(20),
  complemento     VARCHAR2(100),
  bairro          VARCHAR2(100),
  cidade          VARCHAR2(100),
  estado          VARCHAR2(2),
  cep             VARCHAR2(12)
);

CREATE TABLE PACIENTE (
  paciente_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome            VARCHAR2(200) NOT NULL,
  cpf             VARCHAR2(14) UNIQUE,
  rg              VARCHAR2(30),
  data_nascimento DATE,
  sexo            CHAR(1),
  email           VARCHAR2(150),
  rua             VARCHAR2(150),
  numero          VARCHAR2(20),
  complemento     VARCHAR2(100),
  bairro          VARCHAR2(100),
  cidade          VARCHAR2(100),
  estado          VARCHAR2(2),
  cep             VARCHAR2(12),
  plano_id        NUMBER,
  CONSTRAINT fk_paciente_plano FOREIGN KEY (plano_id) REFERENCES PLANO_SAUDE(plano_id)
);

CREATE TABLE TELEFONE_PACIENTE (
  telefone_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  paciente_id     NUMBER NOT NULL,
  tipo            VARCHAR2(30),
  numero          VARCHAR2(30) NOT NULL,
  CONSTRAINT fk_tel_paciente FOREIGN KEY (paciente_id) REFERENCES PACIENTE(paciente_id)
);

CREATE TABLE TELEFONE_PROFISSIONAL (
  telefone_id     NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  profissional_id NUMBER NOT NULL,
  tipo            VARCHAR2(30),
  numero          VARCHAR2(30) NOT NULL,
  CONSTRAINT fk_tel_profissional FOREIGN KEY (profissional_id) REFERENCES PROFISSIONAL(profissional_id)
);

CREATE TABLE ESPECIALIDADE (
  especialidade_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome             VARCHAR2(150) NOT NULL,
  descricao        CLOB
);

-- MEDICO: subtipo, usa o mesmo profissional_id (PK não é identity)
CREATE TABLE MEDICO (
profissional_id NUMBER PRIMARY KEY,
crm             VARCHAR2(60),
CONSTRAINT fk_medico_prof FOREIGN KEY (profissional_id) 
REFERENCES PROFISSIONAL(profissional_id)
);

CREATE TABLE ENFERMEIRO (
  profissional_id NUMBER PRIMARY KEY,
  coren           VARCHAR2(60),
  CONSTRAINT fk_enfermeiro_prof FOREIGN KEY (profissional_id) 
    REFERENCES PROFISSIONAL(profissional_id)
);

CREATE TABLE MEDICO_ESPECIALIDADE (
  id               NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  profissional_id  NUMBER NOT NULL,
  especialidade_id NUMBER NOT NULL,
  CONSTRAINT fk_me_prof FOREIGN KEY (profissional_id) REFERENCES MEDICO(profissional_id),
  CONSTRAINT fk_me_esp  FOREIGN KEY (especialidade_id) REFERENCES ESPECIALIDADE(especialidade_id)
);

CREATE TABLE SETOR (
  setor_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome           VARCHAR2(150) NOT NULL,
  descricao      CLOB,
  localizacao    VARCHAR2(200)
);

CREATE TABLE LEITO (
  leito_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  setor_id       NUMBER NOT NULL,
  numero_leito   VARCHAR2(50),
  tipo           VARCHAR2(50),
  status         VARCHAR2(30),
  CONSTRAINT fk_leito_setor FOREIGN KEY (setor_id) REFERENCES SETOR(setor_id)
);

CREATE TABLE PROCEDIMENTO (
  procedimento_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo          VARCHAR2(60) UNIQUE,
  nome            VARCHAR2(200) NOT NULL,
  descricao       CLOB,
  duracao_estim   NUMBER,
  custo_padrao    NUMBER(12,2)
);

CREATE TABLE AGENDAMENTO (
  agendamento_id  NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  paciente_id     NUMBER NOT NULL,
  profissional_id NUMBER NOT NULL,
  procedimento_id NUMBER,
  data_hora       TIMESTAMP NOT NULL,
  tipo            VARCHAR2(60),
  status          VARCHAR2(30),
  sala            VARCHAR2(50),
  observacoes     CLOB,
  CONSTRAINT fk_ag_paciente FOREIGN KEY (paciente_id) REFERENCES PACIENTE(paciente_id),
  CONSTRAINT fk_ag_profissional FOREIGN KEY (profissional_id) REFERENCES PROFISSIONAL(profissional_id),
  CONSTRAINT fk_ag_procedimento FOREIGN KEY (procedimento_id) REFERENCES PROCEDIMENTO(procedimento_id)
);

CREATE TABLE INTERNACAO (
  internacao_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  paciente_id     NUMBER NOT NULL,
  leito_id        NUMBER,
  medico_responsavel_id NUMBER NOT NULL,
  data_admissao   DATE NOT NULL,
  data_alta       DATE,
  motivo_admissao CLOB,
  status_internacao VARCHAR2(50),
  CONSTRAINT fk_int_paciente FOREIGN KEY (paciente_id) REFERENCES PACIENTE(paciente_id),
  CONSTRAINT fk_int_leito FOREIGN KEY (leito_id) REFERENCES LEITO(leito_id),
  CONSTRAINT fk_int_medico FOREIGN KEY (medico_responsavel_id) REFERENCES PROFISSIONAL(profissional_id)
);

CREATE TABLE EXAME (
  exame_id       NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  paciente_id    NUMBER NOT NULL,
  profissional_solicitante_id NUMBER NOT NULL,
  tipo_exame     VARCHAR2(200),
  data_pedido    DATE NOT NULL,
  prioridade     VARCHAR2(30),
  setor_id       NUMBER,
  CONSTRAINT fk_exame_paciente FOREIGN KEY (paciente_id) REFERENCES PACIENTE(paciente_id),
  CONSTRAINT fk_exame_prof FOREIGN KEY (profissional_solicitante_id) REFERENCES PROFISSIONAL(profissional_id),
  CONSTRAINT fk_exame_setor FOREIGN KEY (setor_id) REFERENCES SETOR(setor_id)
);

CREATE TABLE RESULTADO_EXAME (
  resultado_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  exame_id       NUMBER NOT NULL UNIQUE,
  data_resultado DATE,
  valor_texto    CLOB,
  valor_numero   NUMBER,
  observacao     CLOB,
  CONSTRAINT fk_res_exame FOREIGN KEY (exame_id) REFERENCES EXAME(exame_id)
);

CREATE TABLE MEDICAMENTO (
  medicamento_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  nome           VARCHAR2(200) NOT NULL,
  principio_ativo VARCHAR2(200),
  concentracao   VARCHAR2(100),
  forma          VARCHAR2(100)
);

CREATE TABLE PRESCRICAO (
  prescricao_id  NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  paciente_id    NUMBER NOT NULL,
  profissional_id NUMBER NOT NULL,
  data_prescricao DATE NOT NULL,
  validade       DATE,
  observacoes    CLOB,
  CONSTRAINT fk_presc_paciente FOREIGN KEY (paciente_id) REFERENCES PACIENTE(paciente_id),
  CONSTRAINT fk_presc_prof FOREIGN KEY (profissional_id) REFERENCES PROFISSIONAL(profissional_id)
);

CREATE TABLE PRESCRICAO_ITEM (
  prescricao_item_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  prescricao_id  NUMBER NOT NULL,
  medicamento_id NUMBER NOT NULL,
  dosagem        VARCHAR2(100),
  via            VARCHAR2(50),
  frequencia     VARCHAR2(100),
  duracao        VARCHAR2(100),
  CONSTRAINT fk_pi_presc FOREIGN KEY (prescricao_id) REFERENCES PRESCRICAO(prescricao_id),
  CONSTRAINT fk_pi_medic FOREIGN KEY (medicamento_id) REFERENCES MEDICAMENTO(medicamento_id)
);

CREATE TABLE FATURA (
  fatura_id      NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  paciente_id    NUMBER NOT NULL,
  data_emissao   DATE NOT NULL,
  valor_total    NUMBER(12,2),
  status         VARCHAR2(30),
  CONSTRAINT fk_fatura_paciente FOREIGN KEY (paciente_id) REFERENCES PACIENTE(paciente_id)
);

CREATE TABLE FATURA_ITEM (
  item_id        NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  fatura_id      NUMBER NOT NULL,
  descricao      CLOB,
  quantidade     NUMBER NOT NULL,
  preco_unitario NUMBER(12,2),
  procedimento_id NUMBER,
  CONSTRAINT fk_fi_fatura FOREIGN KEY (fatura_id) REFERENCES FATURA(fatura_id),
  CONSTRAINT fk_fi_proc FOREIGN KEY (procedimento_id) REFERENCES PROCEDIMENTO(procedimento_id)
);

CREATE TABLE PAGAMENTO (
  pagamento_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  fatura_id      NUMBER NOT NULL,
  data_pagamento DATE NOT NULL,
  valor_pago     NUMBER(12,2) NOT NULL,
  forma_pagamento VARCHAR2(50),
  referencia     VARCHAR2(200),
  CONSTRAINT fk_pag_fatura FOREIGN KEY (fatura_id) REFERENCES FATURA(fatura_id)
);

CREATE TABLE HISTORICO (
  historico_id   NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  paciente_id    NUMBER NOT NULL,
  profissional_id NUMBER,
  data_hora      TIMESTAMP NOT NULL,
  tipo           VARCHAR2(50),
  descricao      CLOB,
  CONSTRAINT fk_hist_paciente FOREIGN KEY (paciente_id) REFERENCES PACIENTE(paciente_id),
  CONSTRAINT fk_hist_prof FOREIGN KEY (profissional_id) REFERENCES PROFISSIONAL(profissional_id)
);

INSERT INTO PLANO_SAUDE (nome, operadora, numero_contrato)
VALUES ('Plano Básico', 'SaudePlus', 'CONTR-001');

INSERT INTO PLANO_SAUDE (nome, operadora, numero_contrato)
VALUES ('Plano Premium', 'VidaMais', 'CONTR-002');

-- Profissional que será médico
INSERT INTO PROFISSIONAL (nome, cpf, tipo_profissional, registro, email)
VALUES ('Dr. João Silva', '111.111.111-11', 'Medico', 'REG-001', 'joao@hospital.com');

-- Profissional que será enfermeiro
INSERT INTO PROFISSIONAL (nome, cpf, tipo_profissional, registro, email)
VALUES ('Enf. Maria Souza', '222.222.222-22', 'Enfermeiro', 'REG-002', 'maria@hospital.com');

-- Profissional comum
INSERT INTO PROFISSIONAL (nome, cpf, tipo_profissional, registro, email)
VALUES ('Carlos Técnico', '333.333.333-33', 'Tecnico', 'REG-003', 'carlos@hospital.com');

INSERT INTO MEDICO (profissional_id, crm)
VALUES (1, 'CRM-12345');

INSERT INTO ENFERMEIRO (profissional_id, coren)
VALUES (2, 'COREN-67890');

INSERT INTO ESPECIALIDADE (nome, descricao)
VALUES ('Cardiologia', 'Especialidade do coração');

INSERT INTO ESPECIALIDADE (nome, descricao)
VALUES ('Pediatria', 'Atendimento infantil');

INSERT INTO MEDICO_ESPECIALIDADE (profissional_id, especialidade_id)
VALUES (1, 1);

INSERT INTO SETOR (nome, localizacao)
VALUES ('UTI Adulto', 'Bloco A');

INSERT INTO SETOR (nome, localizacao)
VALUES ('Pediatria', 'Bloco B');

INSERT INTO LEITO (setor_id, numero_leito, tipo, status)
VALUES (1, 'UTI-01', 'Adulto', 'LIVRE');

INSERT INTO LEITO (setor_id, numero_leito, tipo, status)
VALUES (1, 'UTI-02', 'Adulto', 'LIVRE');

INSERT INTO PACIENTE (nome, cpf, data_nascimento, email, plano_id)
VALUES ('Ana Pereira', '444.444.444-44', DATE '1990-05-10', 'ana@gmail.com', 1);

INSERT INTO PACIENTE (nome, cpf, data_nascimento, email, plano_id)
VALUES ('Bruno Costa', '555.555.555-55', DATE '1985-12-20', 'bruno@gmail.com', 21);
-- Deu erro com o plano id 2 pois o oracle por algum motivo criou o 2º plano com id 21 e não 2.

INSERT INTO TELEFONE_PACIENTE (paciente_id, tipo, numero)
VALUES (1, 'Celular', '99999-0000');

INSERT INTO TELEFONE_PACIENTE (paciente_id, tipo, numero)
VALUES (21, 'Residencial', '8888-7777');
-- mesmo bug do id do plano de saude ocorreu aqui.

INSERT INTO PROCEDIMENTO (codigo, nome, duracao_estim, custo_padrao)
VALUES ('PROC-01', 'Consulta Clínica', 30, 250.00);

INSERT INTO PROCEDIMENTO (codigo, nome, duracao_estim)
VALUES ('PROC-02', 'Exame de Sangue', 15);

INSERT INTO AGENDAMENTO (
  paciente_id, profissional_id, procedimento_id, data_hora, tipo, status
) VALUES (
  1, 1, 1, SYSTIMESTAMP + 1, 'Consulta', 'AGENDADO'
);

INSERT INTO INTERNACAO (
  paciente_id, leito_id, medico_responsavel_id, data_admissao, motivo_admissao, status_internacao
) VALUES (
  1, 1, 1, SYSDATE, 'Insuficiência respiratória', 'ATIVO'
);

INSERT INTO MEDICAMENTO (nome, principio_ativo, forma)
VALUES ('Dipirona', 'Metamizol', 'Comprimido');

INSERT INTO MEDICAMENTO (nome, principio_ativo, forma)
VALUES ('Amoxicilina', 'Amoxicilina', 'Cápsula');

INSERT INTO PRESCRICAO (paciente_id, profissional_id, data_prescricao, validade)
VALUES (1, 1, SYSDATE, SYSDATE + 7);

INSERT INTO PRESCRICAO_ITEM (prescricao_id, medicamento_id, dosagem, via, frequencia)
VALUES (1, 1, '500mg', 'Oral', '8/8h');












-- 4-) Triggers para manter integridade complexa 

-- 4.1-) atualizar status do leito

CREATE OR REPLACE TRIGGER trg_internacao_after_insert
AFTER INSERT ON INTERNACAO
FOR EACH ROW
BEGIN
  IF :NEW.leito_id IS NOT NULL THEN
    UPDATE LEITO
    SET status = 'OCUPADO'
    WHERE leito_id = :NEW.leito_id;
  END IF;
END;

CREATE OR REPLACE TRIGGER trg_internacao_after_update_alta
AFTER UPDATE OF data_alta ON INTERNACAO
FOR EACH ROW
WHEN (NEW.data_alta IS NOT NULL AND OLD.data_alta IS NULL)
BEGIN
  IF :NEW.leito_id IS NOT NULL THEN
    UPDATE LEITO
    SET status = 'LIVRE'
    WHERE leito_id = :NEW.leito_id;
  END IF;
END;
 
-- registrar histórico ao criar agendamento
CREATE OR REPLACE TRIGGER trg_agendamento_after_insert_hist
AFTER INSERT ON AGENDAMENTO
FOR EACH ROW
BEGIN
  INSERT INTO HISTORICO (paciente_id, profissional_id, data_hora, tipo, descricao)
  VALUES (:NEW.paciente_id, :NEW.profissional_id, SYSTIMESTAMP, 'AGENDAMENTO',
          'Agendamento criado: ' || NVL(:NEW.tipo,'') || ' - status: ' || NVL(:NEW.status,''));
EXCEPTION
  WHEN OTHERS THEN
    -- Se falhar ao gravar o histórico, não interrompe a criação do agendamento.
    NULL;
END;

-- Procedimentos armazenados para operações comuns 

-- 4.2) Procedimento agendar consulta

CREATE OR REPLACE PROCEDURE agendar_consulta(
  p_paciente_id     IN AGENDAMENTO.paciente_id%TYPE,
  p_profissional_id IN AGENDAMENTO.profissional_id%TYPE,
  p_procedimento_id IN AGENDAMENTO.procedimento_id%TYPE,
  p_data_hora       IN AGENDAMENTO.data_hora%TYPE,
  p_tipo            IN AGENDAMENTO.tipo%TYPE,
  p_status          IN AGENDAMENTO.status%TYPE,
  p_out_id          OUT AGENDAMENTO.agendamento_id%TYPE
)
AS
BEGIN
  -- Verifica paciente
  DECLARE v_count INTEGER;
  BEGIN
    SELECT COUNT(*) INTO v_count FROM PACIENTE WHERE paciente_id = p_paciente_id;
    IF v_count = 0 THEN
      RAISE_APPLICATION_ERROR(-20010, 'Paciente não encontrado.');
    END IF;
  END;

  -- Verifica profissional
  DECLARE v_count2 INTEGER;
  BEGIN
    SELECT COUNT(*) INTO v_count2 FROM PROFISSIONAL WHERE profissional_id = p_profissional_id;
    IF v_count2 = 0 THEN
      RAISE_APPLICATION_ERROR(-20011, 'Profissional não encontrado.');
    END IF;
  END;

  -- Inserção no agendamento
  INSERT INTO AGENDAMENTO (
    paciente_id, profissional_id, procedimento_id, data_hora, tipo, status
  ) VALUES (
    p_paciente_id, p_profissional_id, p_procedimento_id, p_data_hora, p_tipo, p_status
  )
  RETURNING agendamento_id INTO p_out_id;

  -- Inserir histórico (ID gerado automaticamente pelo IDENTITY)
  INSERT INTO HISTORICO (paciente_id, profissional_id, data_hora, tipo, descricao)
  VALUES (p_paciente_id, p_profissional_id, SYSTIMESTAMP, 'AGENDAMENTO',
          'Agendamento ID: ' || p_out_id || ' - ' || NVL(p_tipo,'') );

EXCEPTION
  WHEN OTHERS THEN
    RAISE;
END agendar_consulta;





 -- 4.3) Views para simplificar consultas complexas

 -- Mostra agendamentos com dados do paciente, profissional e procedimento;
 -- formato pronto para exibição.

CREATE OR REPLACE VIEW vw_resumo_agendamento AS
SELECT
  a.agendamento_id,
  a.data_hora,
  TO_CHAR(a.data_hora,'DD-MM-YYYY HH24:MI') AS data_hora_formatada,
  a.tipo,
  NVL(a.status, 'N/A') AS status,
  p.paciente_id,
  p.nome AS paciente_nome,
  p.cpf AS paciente_cpf,
  TRIM(NVL(p.email,'')) || CASE WHEN p.email IS NOT NULL THEN ' ' ELSE '' END ||
    TRIM(NVL((SELECT numero FROM TELEFONE_PACIENTE t WHERE t.paciente_id = p.paciente_id AND ROWNUM = 1),'')) 
    AS contato_paciente,
  prof.profissional_id,
  prof.nome AS profissional_nome,
  proc.procedimento_id,
  proc.nome AS procedimento_nome
FROM AGENDAMENTO a
JOIN PACIENTE p ON a.paciente_id = p.paciente_id
JOIN PROFISSIONAL prof ON a.profissional_id = prof.profissional_id
LEFT JOIN PROCEDIMENTO proc ON a.procedimento_id = proc.procedimento_id;

-- 4.4) Funções e pacotes para encapsular regras de negócio

-- gerencia internações

--  Função utilitária (cria/replace)
CREATE OR REPLACE FUNCTION fn_leito_disponivel(p_leito_id IN LEITO.leito_id%TYPE)
RETURN NUMBER
AS
  v_status LEITO.status%TYPE;
BEGIN
  SELECT status INTO v_status
  FROM LEITO
  WHERE leito_id = p_leito_id;

  IF v_status IS NULL THEN
    RETURN 1; -- considerar livre se status nulo
  ELSIF UPPER(TRIM(v_status)) = 'OCUPADO' THEN
    RETURN 0;
  ELSE
    RETURN 1;
  END IF;
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN NULL;
END fn_leito_disponivel;
/


-- 2) Package spec (cria/replace)
CREATE OR REPLACE PACKAGE pkg_internacao AS
  PROCEDURE abrir_internacao(
    p_paciente_id  IN INTERNACAO.paciente_id%TYPE,
    p_leito_id     IN INTERNACAO.leito_id%TYPE,
    p_medico_id    IN INTERNACAO.medico_responsavel_id%TYPE,
    p_motivo       IN INTERNACAO.motivo_admissao%TYPE,
    p_out_id       OUT INTERNACAO.internacao_id%TYPE
  );

  PROCEDURE dar_alta(
    p_internacao_id IN INTERNACAO.internacao_id%TYPE,
    p_data_alta     IN INTERNACAO.data_alta%TYPE
  );
END pkg_internacao;
/

-- 3) Package body (cria/replace)

CREATE OR REPLACE PACKAGE BODY pkg_internacao AS

  PROCEDURE abrir_internacao(
    p_paciente_id  IN INTERNACAO.paciente_id%TYPE,
    p_leito_id     IN INTERNACAO.leito_id%TYPE,
    p_medico_id    IN INTERNACAO.medico_responsavel_id%TYPE,
    p_motivo       IN INTERNACAO.motivo_admissao%TYPE,
    p_out_id       OUT INTERNACAO.internacao_id%TYPE
  ) IS
    v_disponivel NUMBER;
    v_cnt NUMBER;
  BEGIN
    SELECT COUNT(*) INTO v_cnt FROM PACIENTE WHERE paciente_id = p_paciente_id;
    IF v_cnt = 0 THEN
      RAISE_APPLICATION_ERROR(-20020, 'Paciente não encontrado.');
    END IF;

    v_disponivel := fn_leito_disponivel(p_leito_id);
    IF v_disponivel IS NULL THEN
      RAISE_APPLICATION_ERROR(-20021, 'Leito não existe.');
    ELSIF v_disponivel = 0 THEN
      RAISE_APPLICATION_ERROR(-20022, 'Leito ocupado.');
    END IF;

    INSERT INTO INTERNACAO (
      paciente_id, leito_id, medico_responsavel_id, data_admissao, motivo_admissao, status_internacao
    ) VALUES (
      p_paciente_id, p_leito_id, p_medico_id, SYSDATE, p_motivo, 'ATIVO'
    )
    RETURNING internacao_id INTO p_out_id;

    UPDATE LEITO SET status = 'OCUPADO' WHERE leito_id = p_leito_id;

    INSERT INTO HISTORICO (paciente_id, profissional_id, data_hora, tipo, descricao)
    VALUES (p_paciente_id, p_medico_id, SYSTIMESTAMP, 'INTERNACAO',
            'Internação aberta ID: ' || p_out_id || ' - Leito: ' || p_leito_id);

    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      RAISE;
  END abrir_internacao;


  PROCEDURE dar_alta(
    p_internacao_id IN INTERNACAO.internacao_id%TYPE,
    p_data_alta     IN INTERNACAO.data_alta%TYPE
  ) IS
    v_leito_id INTERNACAO.leito_id%TYPE;
    v_paciente_id INTERNACAO.paciente_id%TYPE;
    v_medico_id INTERNACAO.medico_responsavel_id%TYPE;
  BEGIN
    SELECT leito_id, paciente_id, medico_responsavel_id
      INTO v_leito_id, v_paciente_id, v_medico_id
      FROM INTERNACAO
     WHERE internacao_id = p_internacao_id;

    IF v_leito_id IS NULL THEN
      RAISE_APPLICATION_ERROR(-20023, 'Internação não vinculada a leito.');
    END IF;

    UPDATE INTERNACAO
    SET data_alta = p_data_alta
    WHERE internacao_id = p_internacao_id;

    UPDATE LEITO
    SET status = 'LIVRE'
    WHERE leito_id = v_leito_id;

    INSERT INTO HISTORICO (paciente_id, profissional_id, data_hora, tipo, descricao)
    VALUES (v_paciente_id, v_medico_id, SYSTIMESTAMP, 'ALTA',
            'Alta concedida para internação ID: ' || p_internacao_id);

    COMMIT;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ROLLBACK;
      RAISE_APPLICATION_ERROR(-20024, 'Internação não encontrada.');
    WHEN OTHERS THEN
      ROLLBACK;
      RAISE;
  END dar_alta;

END pkg_internacao;
/

-- testando internação 
DECLARE
  v_id NUMBER;
BEGIN
  pkg_internacao.abrir_internacao(
    p_paciente_id  => 1,
    p_leito_id     => 2,
    p_medico_id    => 1,
    p_motivo       => 'Teste de internação',
    p_out_id       => v_id
  );
  DBMS_OUTPUT.PUT_LINE('Internação criada ID: ' || v_id);
END;
/

SELECT * FROM INTERNACAO ORDER BY internacao_id DESC;
SELECT leito_id, status FROM LEITO WHERE leito_id = 1;
SELECT * FROM HISTORICO ORDER BY historico_id DESC;





-- 4.5) Controle de transações para garantir atomicidade de operações

-- controla faturas e pagamentos
CREATE OR REPLACE PACKAGE pkg_fatura AS
  PROCEDURE gerar_fatura(
    p_paciente_id IN FATURA.paciente_id%TYPE,
    p_data_emissao IN FATURA.data_emissao%TYPE,
    p_valor_total IN FATURA.valor_total%TYPE,
    p_out_id OUT FATURA.fatura_id%TYPE
  );

  PROCEDURE registrar_pagamento(
    p_fatura_id IN PAGAMENTO.fatura_id%TYPE,
    p_valor_pago IN PAGAMENTO.valor_pago%TYPE,
    p_forma IN PAGAMENTO.forma_pagamento%TYPE,
    p_referencia IN PAGAMENTO.referencia%TYPE
  );

  FUNCTION obter_saldo(p_fatura_id IN FATURA.fatura_id%TYPE) RETURN NUMBER;
END pkg_fatura;

DECLARE
  v_fat_id FATURA.fatura_id%TYPE;
BEGIN
  pkg_fatura.gerar_fatura(1, SYSDATE, 500.00, v_fat_id);
  DBMS_OUTPUT.PUT_LINE('Fatura criada ID: ' || v_fat_id);
END;


CREATE OR REPLACE PACKAGE BODY pkg_fatura AS
  PROCEDURE gerar_fatura(
    p_paciente_id IN FATURA.paciente_id%TYPE,
    p_data_emissao IN FATURA.data_emissao%TYPE,
    p_valor_total IN FATURA.valor_total%TYPE,
    p_out_id OUT FATURA.fatura_id%TYPE
  ) IS
  BEGIN
    INSERT INTO FATURA (paciente_id, data_emissao, valor_total, status)
    VALUES (p_paciente_id, p_data_emissao, p_valor_total, 'ABERTA')
    RETURNING fatura_id INTO p_out_id;
    COMMIT;
  EXCEPTION
    WHEN OTHERS THEN
      ROLLBACK;
      RAISE;
  END gerar_fatura;

  PROCEDURE registrar_pagamento(
    p_fatura_id IN PAGAMENTO.fatura_id%TYPE,
    p_valor_pago IN PAGAMENTO.valor_pago%TYPE,
    p_forma IN PAGAMENTO.forma_pagamento%TYPE,
    p_referencia IN PAGAMENTO.referencia%TYPE
  ) IS
    v_total_pago NUMBER;
    v_valor_fatura NUMBER;
  BEGIN
    -- inserir pagamento
    INSERT INTO PAGAMENTO (fatura_id, data_pagamento, valor_pago, forma_pagamento, referencia)
    VALUES (p_fatura_id, SYSDATE, p_valor_pago, p_forma, p_referencia);

    -- calcular total pago
    SELECT NVL(SUM(valor_pago),0) INTO v_total_pago FROM PAGAMENTO WHERE fatura_id = p_fatura_id;
    SELECT NVL(valor_total,0) INTO v_valor_fatura FROM FATURA WHERE fatura_id = p_fatura_id;

    -- atualizar status simples
    IF v_total_pago >= v_valor_fatura THEN
      UPDATE FATURA SET status = 'PAGA' WHERE fatura_id = p_fatura_id;
    ELSIF v_total_pago > 0 THEN
      UPDATE FATURA SET status = 'PARCIAL' WHERE fatura_id = p_fatura_id;
    END IF;
    COMMIT;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      ROLLBACK;
      RAISE_APPLICATION_ERROR(-20030, 'Fatura não encontrada.');
    WHEN OTHERS THEN
      ROLLBACK;
      RAISE;
  END registrar_pagamento;

  FUNCTION obter_saldo(p_fatura_id IN FATURA.fatura_id%TYPE) RETURN NUMBER IS
    v_total_pago NUMBER;
    v_valor_fatura NUMBER;
  BEGIN
    SELECT NVL(SUM(valor_pago),0) INTO v_total_pago FROM PAGAMENTO WHERE fatura_id = p_fatura_id;
    SELECT NVL(valor_total,0) INTO v_valor_fatura FROM FATURA WHERE fatura_id = p_fatura_id;
    RETURN v_valor_fatura - v_total_pago;
  EXCEPTION
    WHEN NO_DATA_FOUND THEN
      RETURN NULL;
  END obter_saldo;

END pkg_fatura;


-- Registrar pagamento
BEGIN
  pkg_fatura.registrar_pagamento(1, 200.00, 'CARTAO', 'REF123');
END;
/

-- Obter saldo
SELECT pkg_fatura.obter_saldo(1) AS saldo FROM DUAL;



 